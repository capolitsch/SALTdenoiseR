% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/masking.R
\name{break_spectrum}
\alias{break_spectrum}
\title{Break a spectrum into segments when one or more wide masks exist}
\usage{
break_spectrum(df_full, break_at = 10, min_pix_segment = 10)
}
\arguments{
\item{df_full}{A tibble with minimal column set
\code{c("wavelength", "I_mask", "Q_mask", "U_mask")}. The values of the mask
columns are 0 (or FALSE) for unmasked pixels and 1 (or TRUE) for masked
pixels.}

\item{break_at}{The minimum number of consecutively-masked spectral pixels
that will trigger a break in the spectrum. Defaults to \code{break_at = 10}.}

\item{min_pix_segment}{After the segmentation procedure is complete, the
resulting segments are examined to ensure that each is sufficiently long for
a non-trivial/well-defined denoising analysis. In particular, any segment
that has less than \code{min_pix_segment} unmasked spectral pixels is discarded.
Defaults to \code{min_pix_segment = 10}.}
}
\value{
A list of tibbles corresponding to the segmented spectrum, as defined
by the above procedure and argument choices. Each tibble in the list
has the same format as the input tibble \code{df_full}, minus the mask columns.
The output tibbles only retain the pixels that are unmasked for every I, Q, U
Stokes parameter, hence the removal of the mask columns.
}
\description{
Break a spectrum into segments when one or more wide masks (i.e. sequences
of many consecutively-masked pixels) exist. The set of masked pixels used to
define the segmentation is taken to be the superset of the pixels that are
masked for the I, Q, or U Stokes parameters. Note that
\code{\link[=denoise_polarized_spectrum]{denoise_polarized_spectrum()}} calls \code{break_spectrum()} internally. So
while \code{break_spectrum()} is an exported function, it does not need to be
called directly in most cases.
}
\examples{
suppressPackageStartupMessages(library(dplyr))
library(tibble)

data(polarized_spectrum_WR_star)

wavelength <- seq(
  from = sci$axDat$crval[1],
  by = sci$axDat$cdelt[1],
  length = sci$axDat$len[1]
) \%>\%
  as_tibble_col(column_name = "wavelength")

stokes <- as_tibble(sci$imDat) \%>\%
  rename_with(function(.cols) c("I", "Q", "U"))

variances <- as_tibble(var$imDat) \%>\%
  select(1:3) \%>\%
  rename_with(function(.cols) c("I_vars", "Q_vars", "U_vars"))

masks <- as_tibble(bpm$imDat) \%>\%
  rename_with(function(.cols) c("I_mask", "Q_mask", "U_mask"))

df_full <- bind_cols(
  wavelength,
  stokes,
  variances,
  masks
)

df_list <- break_spectrum(df_full)
}
